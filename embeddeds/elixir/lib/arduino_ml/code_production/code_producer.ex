defmodule ArduinoML.CodeProducer do

  alias ArduinoML.ProductionHelper, as: Helper
  alias ArduinoML.Application, as: Application

  @doc """
  Returns a string which is the representation in C code of the application.
  """
  def to_code(application) do
    Helper.comment("generated by ArduinoML #Elixir.") <>
      Helper.new_line <>

      Helper.comment("Bricks <~> Pins.") <>
      bricks_declarations(application.sensors ++ application.actuators) <>
      Helper.new_line <>

      Helper.comment("Setup the inputs and outputs") <>
      setup_function(application.sensors, application.actuators) <>
      Helper.new_line <>

      Helper.comment("Static setup code.") <>
      static_setup_declarations() <>
      Helper.new_line <>

      Helper.comment("States declarations.") <>
      states_functions(application.states, application.transitions) <>

      Helper.comment("This function specify the first state.") <>
      loop_function(application)
  end

  defp bricks_declarations([]), do: ""
  defp bricks_declarations([%{label: label, pin: pin} | others]) do
    Helper.statement("int " <> signal_label(label) <> " = " <> pin(pin)) <>
      bricks_declarations(others)
  end

  defp setup_function(sensors, actuators) do
    "void setup() {" <>
      Helper.new_line <>
      setup_bricks(sensors, :input) <>
      Helper.new_line <>
      setup_bricks(actuators, :output) <>
      "}" <>
      Helper.new_line
  end

  defp static_setup_declarations do
    Helper.statement("int state = LOW") <>
      Helper.statement("int prev = HIGH") <>
      Helper.statement("long time = 0") <>
      Helper.statement("long debounce = 200")
  end

  defp states_functions([], _), do: ""
  defp states_functions([state | others], transitions) do
    relevant_transitions = Enum.filter(transitions, fn (transition) -> transition.from == state.label end)
    
    state_function(state, relevant_transitions) <>
      Helper.new_line <>
      states_functions(others, transitions)
  end

  defp loop_function(application) do
    initial_label = Application.initial(application)

    "void loop() {\n" <>
      Helper.statement(initial_label |> state_function_call |> Helper.indented(1)) <>
      "}"    
  end



  defp state_function(%{label: label, actions: actions}, transitions) do
    "void " <> state_function_name(label) <> "() {" <>
      Helper.new_line <>
      actions_lines(actions) <>
      Helper.new_line <>
      ("boolean guard = millis() - time > debounce" |> Helper.statement |> Helper.indented(1)) <>
      Helper.new_line <>
      transitions_lines(transitions) <>
      "else {" <>
      Helper.new_line <>
      (state_function_call(label) |> Helper.statement |> Helper.indented(2)) <>
      Helper.indented("}", 1) <>
      Helper.new_line <>
      "}" <>
      Helper.new_line
  end

  defp transitions_lines(transitions), do: transitions_lines(transitions, true)
  defp transitions_lines([], _), do: ""
  defp transitions_lines([%{from: _, to: to, on: assertions} | others], is_first) do
    (condition_keyword(is_first) <> " (" <> condition(assertions) <> ") {") <>
      Helper.new_line <>
      ("time = millis()" |> Helper.statement |> Helper.indented(2)) <>
      (to |> state_function_call |> Helper.statement |> Helper.indented(2)) <>
      Helper.indented("} ", 1) <>
      transitions_lines(others, false)
  end

  defp condition([]), do: "guard"
  defp condition(assertions) do
    condition = assertions
    |> Enum.map(fn %{sensor_label: label, signal: signal} ->
      "digitalRead(" <> brick_label(label) <> ") == " <> signal_label (signal) end)
    |> Enum.reduce(fn (sub, acc) -> acc <> " && " <> sub end)

    condition <> " && guard"
  end
  
  defp condition_keyword(false), do: "else if"
  defp condition_keyword(true), do: Helper.indented("if", 1)
  
  defp actions_lines([]), do: ""
  defp actions_lines([%{actuator_label: label, signal: signal} | others]) do
    line_content = "digitalWrite(" <> brick_label(label) <> ", " <> signal_label(signal) <> ")"

    (line_content |> Helper.statement |> Helper.indented(1)) <>
      actions_lines(others)
  end
  
  defp setup_bricks([], _), do: ""
  defp setup_bricks([%{label: label, pin: _} | others], stream) do
    line = ("pinMode(" <> brick_label(label) <> ", " <> brick_label(stream) <> ")")
    |> Helper.statement
    |> Helper.indented(1)

    line <> setup_bricks(others, stream)
  end

  defp state_function_call(label), do: state_function_name(label) <> "()"
  
  defp state_function_name(label), do: "state_" <> state_label(label)

  defp state_label(label) when is_atom(label), do: label |> Atom.to_string |> String.downcase
  defp state_label(label) when is_binary(label), do: String.downcase(label)

  defp brick_label(label) when is_atom(label), do: label |> Atom.to_string |> String.upcase
  defp brick_label(label) when is_binary(label), do: String.upcase(label)
 
  defp signal_label(label) when is_atom(label), do: label |> Atom.to_string |> String.upcase
  defp signal_label(label) when is_binary(label), do: String.upcase(label)

  defp pin(value) when is_integer(value), do: Integer.to_string(value)
end
